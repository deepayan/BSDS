---
layout: remark
title: A Sample Session in Python
subtitle: Data Analysis with R and Python
author: Deepayan Sarkar
mathjax: true
---

```{r opts, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
opts_chunk$set(cache = FALSE, cache.path='~/knitr-cache/darp-py-session/', autodep = TRUE,
               comment = "", warning = TRUE, message = TRUE,
			   engine.path = list(python = "/usr/bin/python3"),
               fig.width = 16, fig.height = 7,
               dev = "svg", dev.args = list(pointsize = 20),
               knitr.table.format = "html",
			   fig.path='figures/1-pysession-')
options(warnPartialMatchDollar = FALSE, width = 80)
```


# Starting and Interacting with Python

* Python is typically used interactively

* When we start Python, the command window (or console) displays a prompt, typically `>>>`

* We use Python by entering an expression to be evaluated

* Python evaluates the expression and prints the result

```{python}
1 + 2
```

* It then provides a new prompt and waits for more input

* To **quit** Python, you can use the command `exit()` or `quit()`


<div>
$$
\newcommand{\sub}{_}
$$
</div>

---

# Similarities with R

* User interface is very similar to R

* Most concepts are transferable

--

* We will focus on data analysis tools in Python

* We will mostly replicate what we did in the previous R tutorial

---

# Differences between R and Python

* Python is a _general purpose_ programming language

* R is a _domain specific_ programming language (designed for data analysis)

--

* For our purposes, this means that we need some add-on packages to do data analysis in Python

	* _NumPy_ for vectorized numerical computations
	
	* _Matplotlib_ for plotting and visualization
	
	* _Pandas_ for data frames


---

# Infix and Prefix Notation

* Python uses **infix** notation for standard arithmetic operations, e.g., 

```python
1 + 2
```

--

* General Python expressions are typically function calls of the form `f(a, b)`

```{python}
len("Hello")
```

---

layout: true

# Basic principles: Data types

---

* Python can handle many different kinds of data

* Basic classification: *simple data* and *compound data*

* **Simple Data** includes:

	* Numbers (numeric values, including integers and floating-point numbers):
```python
1     # an integer  
-3.14 # a floating point number
```
--

	*  Logical values:
```python
 True # true  
False # false (or T and F shortcuts)
```
--

	* Strings (enclosed in single or double quotes):
```python
"This is a string 1 2 3 4"
```

---

* We can also have **Symbols** which are used for naming variables or functions:

```python
x  
gdp.data  
this_is_a_symbol
```

* Python uses `.` as a special separator in several contexts

* So unlike in R, it cannot be used in variables names


---

* **Compound Data** primarily consists of

	* **vectors** : ordered collections of elements of the same type
	
	* **lists** : ordered collections with elements of possibly different types

--

* We can define compound data using the built-in list data structure `[ ... ]`
```{python}
[1, 2, 3]
```

* However, these are **not** what we describe as _vectors_ with all elements of the same type

```{python}
[1, 'two', 3]
```

---

* The corresonding R data structure is a list

```{r}
list(1, 'two', 3)
```



---

* Vectors (lists of same type) in Python need **NumPy Array** (`ndarray`)

* We first need to import the NumPy library, conventionally as `np`:

```{python}
import numpy as np
```

--

```{python}
np.array([1, 2, 7])
np.array([1, 'two', 7])
```

--

* This form of _coercion_ happens in R as well

```{r}
c(1, 'two', 3)
```


<!-- * Higher dimensional arrays (matrices) are also supported by NumPy -->

---

layout: false

# The REPL

* A Python session involves interaction between the user and the console (_listener_)

* When we enter an expression, the listener passes it to the _evaluator_

--

* Basic rule:

	* Everything is evaluated

	* The results are (usually) printed
	
	* Once done, listener goes back to listening

* This is the same __Read-Eval-Print-Loop__ model used by R

---

layout: true

# Evaluation rules

---

* Numbers and strings evaluate to themselves:

```{python}
10
"Hello"  
```

---

* Expressions can involve _functions_

* Functions are applied using parentheses, similar to R

```{python}
sqrt(10) # fails
```

--

```{python}
np.sqrt(np.array([10, 100, 1000]))
```

---

* Why do we need a prefix for some functions but not others?

```{python}
len(np.array([10, 100, 1000]))
np.mean(np.array([10, 100, 1000]))
```

--

* Compare with R

```{r}
length(c(10, 100, 1000))
mean(c(10, 100, 1000))
```

---

* This is largely a matter of convention

* In R, we can use namespace notation

```{r}
base::mean(c(10, 100, 1000))
stats::median(c(10, 100, 1000))
```

---

* Conversely in Python, we can bypass the package prefix by importing everything

```{python}
from numpy import *
mean(array([10, 100, 1000]))
median(array([10, 100, 1000]))
```

* However, this is not usually done in Python


---

layout: false

class: center middle

# Elementary Statistical Operations

Fundamental numerical and graphical statistical operations in Python


---

layout: true

# Example dataset: World Social Indicators, 1960

---

.scrollable500[

country|gnppc|pctlit_adult|highered100k
:-------|----:|-----------:|-----------:
Nepal|45|5|56
Afghanistan|50|2.5|12
Laos|50|17.5|4
Ethiopia|55|2.5|5
Burma|57|47.5|63
Libya|60|13|49
Sudan|60|9|34
Tanganyika|61|7.5|9
Uganda|64|27.5|14
Pakistan|70|13|165
China|73|47.5|69
India|73|19.3|220
South Vietnam|76|17.5|83
Nigeria|78|10|4
Kenya|87|22.5|5
Madagascar|88|33.5|21
Congo|92|37.5|4
Thailand|96|68|251
Bolivia|99|32.1|166
Cambodia|99|17.5|18

]

---

* Data from a small subset of countries

* All have relatively low per capita GDP

* Variables

	* `gnppc` : per capita GNP (around 1957), 

	* `pctlit_adult` : adult literacy (%) around 1960

	* `highered100k` : enrollment in higher education per 100,000 population

---

layout: true

# Simple univariate calculations

---

* Simplest statistical data: univariate

* Usually consists of groups of numbers

* We first consider only the data on enrolment in higher education, which are

```
56 12 4 5 63 49 34 9 14 165 69 220 83 4 5 21 4 251 166 18
```

--

* In Python, we represent this data as a  NumPy array using the `np.array()` constructor:

```{python}
np.array([56, 12, 4, 5, 63, 49, 34, 9, 14, 165, 69, 220, 83, 4, 5, 21, 4, 251, 166, 18])
```

---

* NumPy provides the `mean()` function to compute the average of a vector of numbers

```{python}
np.mean(np.array([56, 12, 4, 5, 63, 49, 34, 9, 14, 165, 69, 220, 83, 4, 5, 21, 4, 251, 166, 18]))
```

--

* The **median** of these numbers can be calculated using `np.median()`:

```{python}
np.median(np.array([56, 12, 4, 5, 63, 49, 34, 9, 14, 165, 69, 220, 83, 4, 5, 21, 4, 251, 166, 18]))
```

---

* To avoid re-typing the data, we can assigning it to a variable using the `=` operator.

```{python}
higher.educ = np.array([56, 12, 4, 5, 63, 49, 34, 9, 14, 165, 69, 220, 83, 4, 5, 21, 4, 251, 166, 18])
```

* This will _not_ work because `.` is not allowed in variable names

--

```{python}
higher_educ = np.array([56, 12, 4, 5, 63, 49, 34, 9, 14, 165, 69, 220, 83, 4, 5, 21, 4, 251, 166, 18])
```

* This is known as a **variable assignment**

---

* The symbol `higher_educ` now holds the vector of 20 numbers

* If we evaluate the symbol, Python returns its value.

```{python}
higher_educ
```

---

* We can easily compute numerical descriptive statistics.

```{python}
np.mean(higher_educ)  
np.median(higher_educ)  
np.std(higher_educ, ddof = 1) # Standard deviation (ddof=1 for sample SD)
```

---

layout: true

# Vectorized arithmetic

---

* NumPy also supports **elementwise arithmetic operations** on vectors

* For example, we can add 1 to each value using

```{python}
1 + higher_educ
```

* We can calculate the natural logarithms of the values

```{python}
np.log(higher_educ)
```

---

* Functions can be nested, as we have been doing

```{python}
np.median(np.log(higher_educ))
np.mean(np.log(higher_educ))
```

---

layout: false

# Arithmetic Mean, Geometric Mean, and Median

```{python}
np.mean(higher_educ) # arithmetic mean
np.median(higher_educ) # median
np.exp(np.mean(np.log(higher_educ))) # geometric mean
```

---

layout: false

# Another dataset: Average monthly PM 2.5 levels 

* Recorded at an air quality monitoring station in R.K.Puram (Delhi)

* Over a 3-year period, from January 2021 to December 2023.

```{python}
pm25 = np.array([288, 223, 167, 156, 126, 120, 102, 106, 83, 114, 259, 282, 
                 234, 183, 174, 176, 160, 139, 102, 99, 110, 173, 245, 250, 260, 
                 190, 150, 164, 161, 144, 115, 138, 123, 182, 323, 280])
```

---

# Some numerical summaries

```{python}
np.mean(pm25)  
np.median(pm25)  
np.std(pm25, ddof = 1)  
```

--

* Graphical summaries give better idea of distribution

* We will use the **Matplotlib** package (conventionally imported as `plt`)

```{python}
import matplotlib.pyplot as plt
```

---

# Histogram

* The function `hist()` draws a histogram of the data

```{python pm25-hist}
plt.hist(pm25) # Produces a histogram plot
plt.show()
```

---

# Five-Number Summary

* Standard quartiles + extreme values are useful to judge symmetry

* Useful to compare transformations

```{python}
np.percentile(pm25, [0, 25, 50, 75, 100])
```

---

# Box-and-Whisker Plot

```{python pm25-boxplot}
plt.boxplot(np.log(pm25))
plt.show()
```

---

layout: true

# Time Series Plots

---

* We often plot observations against time (or the order in which they were obtained)

* Helps to convey serial correlation or trend

--

* The `plt.scatter()` function creates a scatterplot of two variables

* To use it, we need a sequence of integers for the time variable

---

* NumPy's `np.arange()` function generates sequences similar to the `seq()` function in R

```{python pm25-ts1}
time = np.arange(0, 36) # creates 0, 1, 2, ... 35
plt.scatter(time, pm25)
```

---

* To connect points by lines, use `plt.plot()`

```{python pm25-ts2}
plt.plot(time, pm25)
```

---

layout: true

# Scatter plots

---

* General scatter plots show points with coordinates given by two variables

* Very useful for examining the relationship between two numerical variables

--

* Recall: `higher_educ` from social indicators data

* Additionally define the `adult_lit` variable to contain corresponding adult literacy (%).

```{python}
adult_lit = np.array([5, 2.5, 17.5, 2.5, 47.5, 13, 9, 7.5, 27.5, 13, 47.5,
                       19.3, 17.5, 10, 22.5, 33.5, 37.5, 68, 32.1, 17.5])
```

---

* Scatter plot of `higher_educ` against `adult_lit`


```{python pm25-alit-hieduc}
plt.scatter(adult_lit, higher_educ)
```

---

layout: true

# Plotting Functions

---

* Sometimes we are interested in plotting functions; e.g., plot $\sin(x)$ from $-\pi$ to $+\pi$

```{python plot-sin-grid}
x_points = np.linspace(-np.pi, np.pi, 50) # equally spaced grid  
plt.plot(x_points, np.sin(x_points))
```

---

* We can alse define a new function to plot 

```{python plot-sin-fun}
def f(x):  
    return 2 * x + 3 * (x ** 2) - (x ** 3)
plt.plot(x_points, f(x_points))
```

---

* Alternatively, we can use a Python `lambda` (R-like anonymous function).

```{python}
plt.plot(x_points, (lambda x: 2 * x + 3 * (x ** 2) - (x ** 3))(x_points))
```


---

layout: true

# Example: Loss Function

---

* The mean and median can be viewed as solutions that minimize a _loss function_

* Sample mean of $X\sub{1}, X\sub{2}, \dotsc, X\sub{n}$:

$$
\arg \min\sub{\theta} \sum\limits\sub{i=1}^n (X\sub{i} - \theta)^2
$$

* Sample median of $X\sub{1}, X\sub{2}, \dotsc, X\sub{n}$:

$$
\arg \min\sub{\theta} \sum\limits\sub{i=1}^n \lvert X\sub{i} - \theta \rvert
$$


---

* The mean and median can be viewed as solutions that minimize a _loss function_

* Sample mean of $X\sub{1}, X\sub{2}, \dotsc, X\sub{n}$:

$$
\arg \min\sub{\theta} L\sub{1}(\theta) \ \text{ where } L\sub{1}(\theta) = \sum\limits\sub{i=1}^n (X\sub{i} - \theta)^2
$$

* Sample median of $X\sub{1}, X\sub{2}, \dotsc, X\sub{n}$:

$$
\arg \min\sub{\theta}  L\sub{2}(\theta) \ \text{ where } L\sub{2}(\theta) = \sum\limits\sub{i=1}^n \lvert X\sub{i} - \theta \rvert
$$

* What do the function $L\sub{1}$ and $L\sub{2}$ look like?

---

* How can we define $L\sub{1}$?

--

```{python}
def SSD0(theta):
    S = 0
    n = len(higher_educ)
    for i in range(n): # for loop
        S = S + (higher_educ[i] - theta) ** 2 # indexing, scope
    return S # value returned by function
```

--

* Useful approach in general, but can also use NumPy vectorization

```{python}
def SSD(theta):
    dev = higher_educ - theta
    return np.sum(dev * dev)
```

---

* Use _list comprehension_ to compute and plot `SSD()`

```{python plot_loss_error}
theta_vals = np.linspace(60, 65, 100)  
loss_vals = np.array([ SSD(t) for t in theta_vals])
plt.plot(theta_vals, loss_vals)
```


---

layout: false

class: center middle

# Generating and Modifying Data

Generating systematic and random data, modifying existing data

---

# Generating Random Data (Simulation)

* R provides functions for generating pseudo-random numbers

* `runif(n)` generates `n` Uniform random variables

```{python}
runif(10)
```

* `rnorm(n)` generates `n` Standard Normal random variables.

```{python}
runif(25)
```


---

layout: true

# Generating Systematic Data

---

* We have seen `seq(start, end)` (or `start:end`) for equally spaced integer sequences

```{python}
seq(10, 19.5)
1:pi
```

* Also `seq(a, b, length.out = n)` for general equally spaced sequences

```{python}
seq(1, pi, length.out = 10)
```

---

* The `rep()` function is useful for generating sequences with specific patterns

* If we want to repeat a sequence:

```{python}
rep(c(1, 2, 3), 2)  
```

* If we want to repeat each element a specified number of times:

```{python}
rep(c(1, 2, 3), times = c(3, 2, 1))  
```

---

layout: true

# Forming Subsets and Deleting Cases

---

* R uses bracket indexing `[]` to select elements from a vector or list

* An important difference is that **R uses 1-based indexing**, and not 0-based indexing

--

* Suppose we define a vector `x`:

```{python}
x = c(3, 7, 5, 9, 12, 3, 14, 2)
```

* To retrieve the second element (index 2), we can use

```{python}
x[[2]]
x[2]
```

---

* To retrieve a _group_ of elements, we must use the second form, with a
vector as index:

```{python}
x[c(1, 3)]
```

--

* To exclude elements, we use negative indices

* To exclude the 3rd element:

```{python}
x[-3]
```

---

* We can also use **logical indexing**

* To select all elements of `x` that are greater than 3:

```{python}
x[x > 3]
```

---

layout: false

# Combining Several Lists

* To combine several short vectors into a single longer vector, use `c()`:

```{python}
z1 = c(1, 2, 3)  
z2 = c(4)
z3 = c(5, 6, 7, 8)  
c(z1, z2, z3)  
```

---

# Modifying Data: Replace values in existing vector

* R uses subsetting combined with assignment

* To change the `12` (the 5th element) in `x` to `11`:

```{python}
x
x[5] = 11  
x  
```

--

* To change elements 1 and 3 to `15` and `16`:

```{python}
x[c(1, 3)] = c(15, 16)  
x  
```

---

# Reference versus copy

* R copies vectors upon modification (does not modify in-place). For example:

```{python}
x
y = x # y is a copy  
x[3] = 100  
x
y
```

* This behavior (implicit copying on modification) simplifies many tasks 

--

* Python does **not** copy implicitly in such situations

* If required, copies must be made explicitly


---

layout: false

class: center middle

# Useful Features

Interacting with the R environment

---

# Getting Help

* Online help is available for most R functions

* You can use the `?` operator followed by the function name, or the `help()` function

```r
?median  
help("median")
```

--

* You may not always know the exact function name beforehand

* You can still use the `??` operator to search the documentation for keywords

```r
??normal
```

---


# Listing and Undefining Variables

* To find out which variables we have defined in the current session:

```{python}
ls()
```

* To remove a variable to free up memory / clean up your workspace:

```{python}
rm(theta_vals, SSD_vals1, SSD_vals2, SSD)
ls()
```

---

# Saving Your Work

* R provides mechanisms to save variables and record sessions.

* To save variables for later use:

```r
save(higher_educ, pm25, file = "examples.rda")
```

* This saves the specified variables to a file in a special binary format

* Can be reloaded later in a different R session using `load("examples.rda")`

---


# Loading files

* Data files saved in R (using `save()`) can be read in using `load()`

```r
load("examples.rda")
```

--

* R code can also be saved in a file (typically with extension `.R`)

* We can run such a script, as a series of commands, using

```r
source("/path/to/script.R")
```

--

* Good practice: Open an "R Script" to write / edit code instead of prompt

* Saving this file keeps a record of what you have done


---

# Importing data stored in other formats

* Small datasets can be typed in at the R console to illustrate basic usage

* Real world datasets are too large for this to be feasible

--

* Typically distributed in a variety of formats

* Easiest to import: text formats such as 

	* CSV (comma-separated values)

	* JSON (JavaScript Object Notation)

--

* Often distributed in proprietary or specialized formats meant for specific software:

	* `.xls` or `.xlsx` files exported by Microsoft Excel

	* `.xpt` files exported by SAS

	* `.sav` files exported by SPSS

	* `.dta` files exported by Stata.

---

# Importing data stored in proprietary formats

* Not always guaranteed that R will be able to read data from such files

* But most common formats are supported (through add-on packages)

* See [R Data
Import/Export](https://cran.isid.ac.in/doc/manuals/r-devel/R-data.html)
manual

* Also covers interacting with data stored in Database Management Systens (useful for large datasets)

--

* Most data import methods will import datasets as _data frames_

* Data frames basically combine multiple columns in a single container

---

layout: true

# Data Frames

---

* Can be constructed explicitly using the `data.frame()` function

* Example: combine `higher_educ` and `adult_lit` along with country names

```{python}
dsocial =
    data.frame(country = c("Nepal", "Afghanistan", "Laos", "Ethiopia",
                           "Burma", "Libya", "Sudan", "Tanganyika",
                           "Uganda", "Pakistan", "China", "India",
                           "South Vietnam", "Nigeria", "Kenya", "Madagascar",
                           "Congo", "Thailand", "Bolivia", "Cambodia"),
               hedu = higher_educ,
               adlit = adult_lit)
```

---

* `dsocial` is now like a matrix / spreadsheet


.scrollable500[

```{python}
dsocial
```

]

---

* Individual "columns" can be extracted using the `$` operator

```{python}
dsocial$country
dsocial$adlit
mean(dsocial$adlit)
```

---

* Can also be imported from file

```{python}
social_indicators =
    read.csv("https://deepayan.github.io/BSDS/2026-01-DARP/slides/data/social-indicators-1964.csv",
             comment.char = "#")
head(social_indicators)
```


---

layout: true

# Plotting data in data frames

---

* Possible using what we already know (but not recommended)

```{python plot-socind-default}
plot(sqrt(dsocial$hedu), sqrt(dsocial$adlit))
```

---

* Formula interface (used extensively in R)

```{python plot-socind-formula}
plot(sqrt(adlit) ~ sqrt(hedu), data = dsocial)
```

---

* Formula interface in __lattice__ add-on package

```{python xyplot-socind, fig.width=8, fig.height=4}
lattice::xyplot(sqrt(adlit) ~ sqrt(hedu), data = dsocial)
```

---

* Similar approach in __ggplot2__ add-on package

```{python ggplot-socind, fig.width=8, fig.height=4}
ggplot2::ggplot(dsocial, mapping = ggplot2::aes(x = sqrt(hedu), y = sqrt(adlit))) + ggplot2::geom_point()
```

---

* Same plot for all countries in Original source: World handbook of
  political and social indicators, 1964

```{python xyplot-socind-all, fig.width=8, fig.height=4}
lattice::xyplot(sqrt(Percent.Adult_Literacy) ~ sqrt(Higher.Ed.per.100000), data = social_indicators)
```

---

* Data in original units

```{python xyplot-socind-raw, fig.width=8, fig.height=4}
lattice::xyplot(Percent.Adult_Literacy ~ Higher.Ed.per.100000, data = social_indicators)
```



