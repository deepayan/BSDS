---
layout: remark
title: Basic Usage of R
subtitle: Data Analysis with R and Python
author: Deepayan Sarkar
mathjax: true
---

	
# R is a full programming language

* Variables

* Functions

* Control flow structures

	* For loops, while loops

	* If-then-else (branching)

--

* Distinguishing features

	* Focus on _vectors_ and _vectorized operations_ 

	* Treatment of _functions_ at par with other object types


```{r opts, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
library(knitr)
library(kableExtra)
opts_chunk$set(cache = TRUE, cache.path='~/knitr-cache/darp-basics/', autodep = TRUE,
               comment = "", warning = TRUE, message = TRUE,
               fig.width = 12, fig.height = 5.5,
               dev = "svglite", dev.args = list(pointsize = 15, bg = "transparent"),
               knitr.table.format = "html",
               fig.path='figures/2-basics-')
opts_chunk$set(engine.path = list(python = '/usr/local/bin/python3'))
options(warnPartialMatchDollar = FALSE, width = 90) # 110
```



<div>
$$
\newcommand{\sub}{_}
$$
</div>


---

# R is easily extensible

* Most standard data analysis methods are already implemented

* Can be extended by writing add-on packages

* Thousands of add-on packages are available

---

# Major concepts we need to know

* Variables (in the context of programming)

--

* Data structures needed for data analyis

--

* Functions (set of instructions for performing a procedure)

---

# Variables

* Variables are symbols that may be associated with different values

* Computations involving variables are done using their current value

```r
sqrt(x)
```

```
Error: object 'x' not found
```

---

# Variables

* Variables are symbols that may be associated with different values

* Computations involving variables are done using their current value


```{r}
x <- 10 # assignment
sqrt(x)
x <- -1
sqrt(x)
x <- -1+0i
sqrt(x)
```

---

# Data structures for data analysis

* Vectors

* Matrices 

* Data frames (a spreadsheet-like data set)

* Lists (general collection of objects)

---

# Atomic vectors

* Indexed collection of homogeneous scalars, can be 

    * Numeric / Integer / Complex

    <!-- * Categorical (factor) -->

    * Character

    * Logical (`TRUE` / `FALSE`)
	
--

* Missing values are allowed, indicated as `NA`


--

* Elements are indexed starting from 1


--

* $i$th element of vector `x` can be extracted using `x[[i]]`

* There are also more sophisticated forms of (vector) indexing



---

# Atomic vectors: examples

```{r}
month.name # built-in 
```


--

```{r}
x <- rnorm(10)
x
```


--

```{r}
x[[3]] # third element of x
```

---

# Atomic vectors: examples

```{r}
str(x) # useful function
str(month.name)
```

---

# Creating atomic vectors

* Constructor functions

```{r}
numeric(10)
logical(5)
character(5)
```

---

# Scalars are also vectors

* "Scalars" are just vectors of length 1

```{r}
str(numeric(2))
str(numeric(1))
str(0)
```

---

# Vectors can have zero length

* Vectors can have length zero 

```{r}
numeric(0)
logical(0)
length(character(0))
```

--

```{r}
length(NULL)
```

---

# Combining vectors using `c()` 

* Vectors can also be created by combining smaller vectors

* For example, vectors `x` and `y` can be combined using `c(x, y)`

```{r}
c(1:5, numeric(3))
```

--

* Any number of vectors can be combined

* This is a common way to build up a vector using scalars

```{r}
c(2, 4, 6, 9, 11)
```

---

# Combining vectors of different types

* Atomic vectors of different types cannot be combined

* Attempting to do so will convert into one of the types

```{r}
c(1:5, c(TRUE, FALSE))
c(1:5, month.name[[1]])
```

--


```{r}
c(1:5, c(TRUE, FALSE), month.name[[1]])
c(c(1:5, TRUE, FALSE), month.name[[1]])
```

---


# Example: Our first dataset

* Life expectancy in different countries over time

```{r,echo=FALSE}
## library(pander)
g <- read.table("data/gapminder.tsv", sep = "\t", header = TRUE)
keep.countries <- c("Australia", "France", "India", "Zimbabwe")
lexp.long <- subset(g, country %in% keep.countries, select = c(country, year, lifeExp))
lexp.wide <- reshape(lexp.long, direction = "wide", idvar = "year", timevar = "country")
names(lexp.wide) <- gsub("lifeExp.", "", names(lexp.wide), fixed = TRUE)
rownames(lexp.wide) <- NULL
kable (lexp.wide)
```

---

layout: true

# Life Exepectancy in France

---

```{r}
year <- c(1952, 1957, 1962, 1967, 1972, 1977,
          1982, 1987, 1992, 1997, 2002, 2007)
year
```


--

```{r}
lexp_france <- c(67.41, 68.93, 70.51, 71.55, 72.38, 73.83, 74.89, 76.34,
              77.46, 78.64, 79.59, 80.657)
lexp_france
```


---


```{r}
year <- seq(1952, 2007, by = 5)
year
```

---

```{r}
plot(year, lexp_france, pch = 16)
```


---

```{r}
lexp_france[[2]] - lexp_france[[1]]
```

---

```{r}
c(lexp_france[[2]] - lexp_france[[1]], lexp_france[[3]] - lexp_france[[2]],
  lexp_france[[4]] - lexp_france[[3]], lexp_france[[5]] - lexp_france[[4]],
  lexp_france[[6]] - lexp_france[[5]], lexp_france[[7]] - lexp_france[[6]],
  lexp_france[[8]] - lexp_france[[7]], lexp_france[[9]] - lexp_france[[8]],
  lexp_france[[10]] - lexp_france[[9]], lexp_france[[11]] - lexp_france[[10]],
  lexp_france[[12]] - lexp_france[[11]])
```

---

```{r}
d <- numeric(0)
```


--

```{r}
for (i in 1:11) {
    d <- c(d, lexp_france[[i+1]] - lexp_france[[i]])
}
d
```

---

```{r}
lexp_france[-1] - lexp_france[-12]
```


--

```{r}
diff(lexp_france)
```

---

```{r}
d <- diff(lexp_france)
median(d)
mean(d)
```

---

```{r}
plot(d, pch = 16, type = "o", ylab = "difference", xlab = "period")
```

---

layout: false

# Types of vector indexing

* Indexing refers to extracting subsets of data

* R supports several kinds of indexing:

	* Indexing with a vector of positive integers

	* Indexing with a vector of negative integers
	
	* Indexing with a logical vector

	* Indexing with a vector of names


---

# The empty index

* A vector indexing operation has the form `x[index]`

???

Vector indexing is done using the _single_ square bracket notation,
where the expression inside the brackets is known as the index.

The index can itself be a vector, unlike the _double_ square bracket
notation, where it is usually a scalar.

--

* The most basic form is an empty index, which selects all elements

```{r}
month.name[]
```

???

Before seeing what the index can be, we should know that the index can
be _missing_, which has the effect of selecting _all_ elements.

This may seem pointless, but will be very useful when we get to matrix
indexing.

---

# Indexing with an integer vector

* For integer indexing, `index` is an integer vector

```{r}
month.name[c(2, 4, 6, 9, 11)]
```

???

Indexing by integers is perhaps the most natural kind of indexing, and
indeed, the index can be a vector of integers. 

The result will have the same length as the _index_, with each
position containing the corresponding element of the vector being indexed.

--

* Elements can be repeated

```{r}
month.name[c(2, 2, 6, 4, 6, 11)]
```

???

Values can be _repeated_ in the index vector, resulting in the
corresponding elements being selected more than once.

This may seem surprising, but it is quite natural in many situations,
for example, when sampling _with_ replacement.

---

# Indexing with an integer vector

* "Out-of-bounds" indexing gives `NA` (missing)

```{r}
month.name[13]
```

???


An index value is permitted to go beyond the range of valid positions,
that is, the length of the vector being indexed. This results in an NA
or missing value in the corresponding position.

--

```{r}
seq(1, by = 2, length.out = 8)
```

???

Here we use the S-E-Q, or SEQUENCE function, to generate a regularly
spaced sequence. This is more general than creating a sequence of
consecutive integers using the colon operator.

--

```{r}
month.name[seq(1, by = 2, length.out = 8)]
```

???

Here we create a sequence whose last two values are out of bounds, so
indexing with it leads to NA values in the result. 

Unfortunately this does not produce an error or warning message, so we
must be careful to check that this does not happen unintentionally.


---

# Indexing with an integer vector

* Indexing with a scalar (vector of length 1) also works:

```{r}
month.name[2]
```

???

Scalars are also vectors, so we can index by a scalar integer as well,
resulting in a scalar value.

--

* This is usually the same as `x[[index]]`

```{r}
month.name[[2]]
```

???

This is the essentially the same as scalar indexing by _double_ square
brackets, 

--

* However, these differ in the behaviour when an index is out of bound

```{r}
month.name[15]
month.name[[15]]
```

???

except that in _scalar_ indexing, an out-of-bounds index
_does_ lead to an error.

---

# Indexing with a vector of negative integers

* Negative integers omit the specified entries

```{r}
month.name[-2]
month.name[-c(2, 4, 6, 9, 11)]
```

???

A more unusual type of indexing is with negative integers.

This has the effect of returning all elements EXCEPT the ones
specified. This is sometimes quite convenient, but you will probably
not use it as much as indexing with positive integers.

--

* Cannot be mixed with positive integers

```{r}
month.name[c(2, -3)]
```

???

Naturally, you cannot mix positive and negative integers in the same
index vector, because the result would be ambiguous.


---

# Indexing with 0

* Zero has a special meaning - it doesn't select anything

```{r}
month.name[0]
month.name[integer(0)] ## same as empty index
month.name[c(1, 2, 0, 11, 12)]
month.name[-c(1, 2, 0, 11, 12)]
```

???

The remaining integer, zero, has a special meaning as an index, in the
sense that it does not select anything, and is essentially ignored
when included in the index vector. 

This is not something you are likely to use, but it _is_ something to be
aware of.

---

# Indexing with a logical vector

* Indexing by logical vector: select `TRUE` elements

```{r}
month.name[c(TRUE, FALSE, FALSE)] # index replicated
```

???

Another very important type of indexing is by _logical_ vectors. This
may initially seem unnecessary given integer indexing, but the
advantages will soon become clear.

In theory, a logical index vector can have any length. But the rule is
designed with the expectation that the logical vector will have the
same length as the vector being indexed. 

So, each element will be either included in the result or excluded,
depending on whether the corresponding index position is TRUE or
FALSE.

In this example, the index vector is shorter than the vector being
indexed.

In such a case, the standard vectorization rule will be applied, and
the index vector will be replicated as necessary to make it as long as
the input.

Make sure you understand this rule, and look carefully at the example
to make sure that the output is what you expect.

---

# Indexing with a logical vector

* Indexing by logical vector: select `TRUE` elements

```{r}
i <- substring(month.name, 1, 1) == "J"
i
```

???

This example illustrates a more typical usage of logical indexing.

Here, we want to select all months that start with the letter J. To do
this, we first use the SUBSTRING function to extract the first letter
of each month, and then check whether this letter equals J.

All these operations are vectorized, so the result is a logical vector
of length 12.

--

```{r}
month.name[i]
```

???

Using it as the index will now extract the months that
we wanted.


---

# Indexing with a logical vector

<!-- * Common use: extract subset satisfying a certain condition (also called "filtering") -->

```{r}
(x <- rnorm(20))
x > 0
x[x > 0]
mean(x[x > 0])
```

???

This kind of filtering operation, where we extract the subset of a
vector satisfying a certain condition, is very common. 

Here is another example, where we extract the positive values from a
vector and compute their mean.


---

# Converting a logical index vector to integer

* Logical indexing may be replaced by integer indexing using `which()`

```{r}
i
which(i)
```

???

There is a very useful function called WHICH, that converts a logical
vector into an integer vector containing the position of the TRUE
elements. 

--

```{r}
month.name[ which(i) ]
```

???

This integer vector can be used as an index instead of the logical
vector to give the same result.

This is sometimes useful, especially if the logical index vector is
very long and only a few elements are TRUE.

--

```{r}
month.name[ -which(i) ] # same as month.name[ !i ]
```

???

Using the corresponding negative integers to index has the effect of
reversing the selection, which is also a nice symmetry.

---

# Converting a logical index vector to integer

* But be careful about zero-length indices

```{r}
which(substring(month.name, 1, 1) == "B")
month.name[ which( substring(month.name, 1, 1) == "B") ]
-which(substring(month.name, 1, 1) == "B") 
month.name[ -which( substring(month.name, 1, 1) == "B") ]
```

???

But you should be careful with this feature when there is a
possibility that the logical vector only has FALSE values. 

In this case, WHICH will return an empty vector, which will not work
as expected when used as a negative index.

---

layout: true

# Indexing with a vector of names

---

- Vectors can optionally have names â€” one for each element

- These are usually informative labels

???

The last kind of indexing is with names or character strings. This
only works for vectors that _have_ names. 

Names are an optional attribute that any vector may have. When
present, each element must have a name, and it usually conveys some
information about the corresponding element. 

This means, that the names associated with a vector is _itself_ a
vector of character strings.

--

- Example: quantiles of a Normal random sample

```{r}
x <- rnorm(100)
qx <- quantile(x)
qx
names(qx)
```

???

In this example, we simulate a random sample from the standard normal
distribution, and call the quantile function on it. 

By default, this function returns a vector containing five quantiles,
the minimum, maximum, median, and the two quartiles, with names to
indicate the corresponding probability.

--

```{r}
names(x) # no names
```

???

As we can see here, the random sample itself does not have
names. Trying to extract the names using the NAMES function returns
NULL.

---

- When present, names may be used to identify elements

- Indexing with names works in the same way as positive integers

- Instead of position, the corresponding named element is selected

```{r}
qx[["50%"]] ## extracting a single element using scalar indexing
qx["50%"]   ## extracting a single element with vector indexing
qx[c("25%", "75%")]  ## extracting multiple elements
```

???

For vectors that do have names, indexing with names works in the same
way as positive integers. 

Instead of positive integers, the index contains character strings,
and the corresponding element is selected.

---

* Inter-quartile range

```{r}
diff(qx[c("25%", "75%")])
```

???

As you may recall, the _difference_ between the third quartile and the
first quartile is known as the __inter-quartile range__.

As a measure of variability in a dataset, it is a common alternative
to the standard deviation, because it is more _robust_.

Using the DIFF function we have seen earlier, we can now easily
calculate the inter-quartile range.

--

```{r}
IQR(x)
```

???

Of course, being a common summary measure, there is also a built-in
function to compute it, named I-Q-R.

---

- Unmatched names are treated like out-of-bound indexes

```{r}
qx[["95%"]]
qx["95%"]
```



